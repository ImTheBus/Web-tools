<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>IMTHEBUS tools – Feedback scale</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Shared base styles and core helpers -->
  <link rel="stylesheet" href="assets/imthebus-base.css" />
  <script src="assets/imthebus-core.js" defer></script>

  <!-- External libs used only on this page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>

  <style>
    main.page {
      align-items: flex-start;
    }

    .b2p-sidebar {
      position: relative;
      padding-top: 1.4rem;
    }

    .b2p-sidebar-inner {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .b2p-sidebar-title {
      font-size: 1.15rem;
      margin: 0;
      line-height: 1.2;
    }

    .b2p-sidebar-text {
      font-size: 0.9rem;
      margin: 0;
    }

    .b2p-sidebar-meta-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }

    .b2p-sidebar-meta-row label {
      display: block;
      font-size: 0.8rem;
      margin-bottom: 0.1rem;
    }

    .b2p-sidebar-meta-row input,
    .b2p-sidebar-meta-row select {
      width: 100%;
      font: inherit;
      font-size: 0.85rem;
      border-radius: 999px;
      border: 2px solid #000;
      padding: 0.28rem 0.55rem;
      background: #fff;
    }

    .b2p-context-row {
      margin-top: 0.25rem;
    }

    .b2p-context-custom {
      margin-top: 0.3rem;
    }

    .b2p-context-custom input {
      width: 100%;
      font: inherit;
      font-size: 0.85rem;
      border-radius: 999px;
      border: 2px solid #000;
      padding: 0.28rem 0.55rem;
      background: #fff;
    }

    .b2p-assessment-count {
      font-size: 0.8rem;
      margin-top: 0.2rem;
    }

    /* Sidebar collapsible sections */

    .sidebar-section {
      border-radius: 18px;
      border: 2px solid #000;
      background: #fff;
      margin-top: 0.4rem;
      overflow: hidden;
    }

    .sidebar-section-header {
      width: 100%;
      background: #fff;
      border: none;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 0.45rem 0.7rem;
      font: inherit;
      cursor: pointer;
    }

    .sidebar-section-title {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .sidebar-section-toggle {
      font-size: 0.95rem;
      padding-left: 0.5rem;
    }

    .sidebar-section-body {
      padding: 0.35rem 0.7rem 0.55rem;
      font-size: 0.82rem;
      display: none;
    }

    .sidebar-section.open .sidebar-section-body {
      display: block;
    }

    .sidebar-section-body p {
      margin: 0.25rem 0;
    }

    .sidebar-section-body ul {
      margin: 0.25rem 0 0.25rem 1rem;
      padding: 0;
    }

    .b2p-sidebar-load-row {
      margin-top: 0.4rem;
      font-size: 0.82rem;
    }

    .b2p-sidebar-load-row label {
      display: block;
      margin-bottom: 0.1rem;
    }

    .b2p-sidebar-load-row select {
      width: 100%;
      font: inherit;
      font-size: 0.85rem;
      border-radius: 999px;
      border: 2px solid #000;
      padding: 0.25rem 0.55rem;
      background: #fff;
    }

    .sidebar-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.3rem;
      margin-top: 0.55rem;
    }

    .sidebar-buttons button {
      font: inherit;
      font-size: 0.8rem;
      border-radius: 999px;
      border: 2px solid #000;
      padding: 0.3rem 0.4rem;
      cursor: pointer;
      background: #fff;
      transition: background 0.12s ease-out, transform 0.08s ease-out;
      white-space: nowrap;
    }

    .sidebar-buttons button.primary {
      background: #000;
      color: #fff;
    }

    .sidebar-buttons button.danger {
      border-color: #b91c1c;
    }

    .sidebar-buttons button:hover {
      transform: translateY(1px);
    }

    .sidebar-note {
      font-size: 0.78rem;
      margin: 0.4rem 0 0;
    }

    /* Board layout */

    .b2p-board-inner {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .b2p-board-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: flex-start;
      margin-bottom: 0.25rem;
    }

    .b2p-board-header .page-title {
      margin-bottom: 0.15rem;
    }

    .b2p-board-header .page-subtitle {
      max-width: 34rem;
      margin: 0;
      font-size: 0.9rem;
    }

    .board-toolbar {
      display: flex;
      gap: 0.35rem;
      align-items: center;
    }

    .board-toolbar .btn {
      font-size: 0.8rem;
    }

    .b2p-board-body {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 0.75rem;
      align-items: flex-start;
    }

    .b2p-column {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }

    /* Question sections */

    .question-section {
      border-radius: 16px;
      border: 2px solid #000;
      background: #fff;
      margin-bottom: 0.45rem;
      overflow: hidden;
    }

    .question-section-header {
      padding: 0.45rem 0.7rem;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .question-section-title-group {
      display: flex;
      flex-direction: column;
    }

    .question-section-title {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .question-section-subtitle {
      font-size: 0.78rem;
    }

    .question-section-toggle {
      font-size: 0.95rem;
      padding-left: 0.5rem;
    }

    .question-section-body {
      display: none;
      padding: 0 0.7rem 0.55rem;
    }

    .question-section.open .question-section-body {
      display: block;
    }

    .question-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    .question-table thead th {
      border-bottom: 1px solid #000;
      padding: 0.2rem 0.2rem;
    }

    .question-table tbody td {
      padding: 0.25rem 0.2rem;
      vertical-align: middle;
    }

    .question-text {
      width: 60%;
      text-align: left;
    }

    .response-cell {
      text-align: center;
    }

    .response-radio {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 2px solid #000;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .response-radio input {
      display: none;
    }

    .response-radio span {
      user-select: none;
    }

    .response-radio.selected {
      background: #000;
      color: #fff;
    }

    .calculate-row {
      margin-top: 0.65rem;
      display: flex;
      justify-content: flex-start;
    }

    .calculate-row button {
      font: inherit;
      font-size: 0.9rem;
      border-radius: 999px;
      border: 2px solid #000;
      background: #000;
      color: #fff;
      padding: 0.45rem 1.1rem;
      cursor: pointer;
      transition: background 0.15s ease-out, transform 0.08s ease-out;
    }

    .calculate-row button.calculating {
      background: #1f2937;
      transform: translateY(1px);
    }

    /* Right column panels */

    .donut-panel {
      border-radius: 16px;
      border: 2px solid #000;
      background: #fff;
      padding: 0.6rem 0.8rem 0.7rem;
      margin-bottom: 0.6rem;
    }

    .donut-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.3rem;
    }

    .donut-header-title {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .donut-header-note {
      font-size: 0.75rem;
      color: #555;
    }

    #zoneRing {
      width: 100%;
      height: 220px;
      display: block;
    }

    .zone-legend-row {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.78rem;
      margin-top: 0.15rem;
    }

    .zone-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .zone-legend-label {
      flex: 1;
    }

    .zone-legend-value {
      min-width: 2.2rem;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .results-panel,
    .overall-panel,
    .entries-panel {
      border-radius: 16px;
      border: 2px solid #000;
      background: #fff;
      padding: 0.7rem 0.8rem;
      font-size: 0.85rem;
      margin-bottom: 0.6rem;
    }

    .results-panel h3,
    .overall-panel h3,
    .entries-panel h3 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
      font-weight: 600;
    }

    .results-panel p,
    .overall-panel p {
      margin: 0.25rem 0;
    }

    .results-panel table,
    .overall-panel table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.35rem;
      font-size: 0.8rem;
    }

    .results-panel th,
    .results-panel td,
    .overall-panel th,
    .overall-panel td {
      border: 1px solid #000;
      padding: 0.25rem 0.3rem;
      vertical-align: top;
    }

    .conversation-prompts {
      margin-top: 0.4rem;
      font-size: 0.8rem;
    }

    .conversation-prompts ul {
      margin: 0.25rem 0 0.25rem 1rem;
      padding: 0;
    }

    .entries-panel table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }

    .entries-panel th,
    .entries-panel td {
      border: 1px solid #000;
      padding: 0.2rem 0.25rem;
      text-align: left;
    }

    .entries-panel th {
      background: #f5f5f5;
    }

    /* Export tweaks */

    .export-header {
      border-radius: 16px;
      border: 2px solid #000;
      background: #fff;
      padding: 0.6rem 0.8rem 0.7rem;
      margin-bottom: 0.6rem;
      font-size: 0.85rem;
    }

    .export-header-title {
      font-weight: 700;
      font-size: 1rem;
      margin-bottom: 0.2rem;
    }

    .export-header-meta {
      font-size: 0.8rem;
      margin-bottom: 0.25rem;
    }

    .export-highlight {
      font-size: 0.82rem;
      margin-bottom: 0.25rem;
    }

    .export-suggestion {
      font-size: 0.8rem;
      font-style: italic;
    }

    .export-footer {
      margin-top: 0.6rem;
      font-size: 0.78rem;
    }

    .export-mode {
      background: #fff;
    }

    @media (max-width: 960px) {
      .b2p-board-body {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body data-counter-key="feedback-scale">
  <div data-include="partials/header.html"></div>

  <main class="page">
    <!-- Sidebar -->
    <aside class="sidebar-card b2p-sidebar">
      <div class="b2p-sidebar-inner">
        <h2 class="b2p-sidebar-title">Feedback scale assessment</h2>
        <p class="b2p-sidebar-text">
          This tool helps you and your manager understand how feedback feels at the moment. It maps your
          answers to five zones: Silent, Sparse, Resonant, Loud and Overwhelming, giving you a shared
          language for how feedback is landing and what would make it more constructive.
        </p>

        <!-- Details first, open by default -->
        <div class="sidebar-section open" id="detailsSection">
          <button type="button" class="sidebar-section-header">
            <span class="sidebar-section-title">Details for this assessment</span>
            <span class="sidebar-section-toggle">+</span>
          </button>
          <div class="sidebar-section-body">
            <div class="b2p-sidebar-meta-row">
              <div>
                <label for="personName">Name (optional)</label>
                <input id="personName" type="text" placeholder="Name" />
              </div>
              <div>
                <label for="roleLevel">Role level</label>
                <select id="roleLevel">
                  <option value="">Select role level</option>
                  <option value="L1">L1 – Operator</option>
                  <option value="L2">L2 – Senior operator</option>
                  <option value="L3">L3 – Supervisor</option>
                  <option value="L4">L4 – Manager</option>
                  <option value="L5">L5 – Director</option>
                </select>
              </div>
            </div>

            <div class="b2p-context-row">
              <label for="contextSelect">Context</label>
              <select id="contextSelect">
                <option value="">Whole role</option>
                <option value="Last 2 weeks">Last 2 weeks</option>
                <option value="Last 3 months">Last 3 months</option>
                <option value="Performance or salary review period">Performance or salary review period</option>
                <option value="Specific project or team">Specific project or team</option>
                <option value="User-defined">Something else (describe)</option>
              </select>
            </div>

            <div class="b2p-context-custom" id="contextCustomWrapper" style="display:none;">
              <label for="contextCustom">Describe the context</label>
              <input id="contextCustom" type="text" placeholder="For example: new role, review cycle, project, etc." />
            </div>

            <p class="b2p-assessment-count">
              Assessments completed in this browser: <strong id="assessmentCount">0</strong>
            </p>
          </div>
        </div>

        <!-- About second -->
        <div class="sidebar-section" id="aboutSection">
          <button type="button" class="sidebar-section-header">
            <span class="sidebar-section-title">About this tool</span>
            <span class="sidebar-section-toggle">+</span>
          </button>
          <div class="sidebar-section-body">
            <p>
              This tool turns gut feelings about feedback into a simple picture. It does not judge people. It
              shows how much of your feedback experience sits in silence, useful conversation, or noisy and
              hard to use feedback.
            </p>
            <p>
              <strong>Resonant feedback</strong> is usually the most constructive. It is specific, timely and
              focused on what to repeat or change next time. Silent and Overwhelming feedback make it harder
              to learn, but they are still useful signals that something in the system needs adjusting.
            </p>
            <p>
              Use the results as a shared problem to solve. The aim is to agree simple experiments that make
              feedback clearer, safer and more workable for both of you.
            </p>
          </div>
        </div>

        <div class="sidebar-section">
          <button type="button" class="sidebar-section-header">
            <span class="sidebar-section-title">Saved assessments</span>
            <span class="sidebar-section-toggle">+</span>
          </button>
          <div class="sidebar-section-body">
            <div class="b2p-sidebar-load-row">
              <label for="loadEntry">Load a previous result</label>
              <select id="loadEntry">
                <option value="">Select saved entry</option>
              </select>
            </div>

            <div class="sidebar-buttons">
              <button id="saveEntry" type="button" class="primary">Save current view</button>
              <button id="exportCsv" type="button">Export CSV</button>
              <button id="clearEntries" type="button" class="danger">Clear all</button>
            </div>

            <p class="sidebar-note">
              Entries stay in this browser only. Use CSV or PDF to keep a record elsewhere.
            </p>
          </div>
        </div>
      </div>
    </aside>

    <!-- Board -->
    <section class="board-wrapper" id="boardWrapper">
      <div class="board-inner-shell b2p-board-inner" id="boardInner">
        <div class="b2p-board-header">
          <div>
            <div class="page-title">Feedback scale assessment board</div>
            <p class="page-subtitle">
              Map how feedback has felt across Silent, Sparse, Resonant, Loud and Overwhelming, then compare
              it to a typical pattern for your role level.
            </p>
          </div>
          <div class="board-toolbar">
            <button type="button" class="btn btn-pill-small" id="fullscreenToggle">Fullscreen board</button>
            <button type="button" class="btn btn-pill-small" id="exportPdf">Save as PDF</button>
          </div>
        </div>

        <div class="b2p-board-body" id="boardBody">
          <!-- Left: questions -->
          <div class="b2p-column">
            <div id="questionSections"></div>
            <div class="calculate-row">
              <button id="calculateFromQuestions" type="button">Calculate from answers</button>
            </div>
          </div>

          <!-- Right: ring chart and results -->
          <div class="b2p-column">
            <div class="donut-panel">
              <div class="donut-header">
                <div class="donut-header-title">Feedback pattern</div>
                <div class="donut-header-note" id="donutLabel">
                  Equal starting pattern. Updates after calculation.
                </div>
              </div>
              <canvas id="zoneRing" width="260" height="220"></canvas>
              <div id="zoneRingLegend"></div>
            </div>

            <div class="results-panel">
              <h3>Calculated zones and scores</h3>
              <div id="calculationResults">
                Answer the questions and click <strong>Calculate from answers</strong> to see your distribution
                across Silent, Sparse, Resonant, Loud and Overwhelming feedback.
              </div>
            </div>

            <div class="overall-panel">
              <h3>Overall feedback pattern</h3>
              <div id="overallResult">
                Select a role level to compare your pattern against a typical target for that role.
              </div>
            </div>

            <div class="entries-panel">
              <h3>Recorded entries in this browser</h3>
              <table id="entriesTable">
                <thead>
                  <tr>
                    <th>Timestamp</th>
                    <th>Silent%</th>
                    <th>Sparse%</th>
                    <th>Resonant%</th>
                    <th>Loud%</th>
                    <th>Over%</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <div data-include="partials/footer.html"></div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      /* Sidebar collapsibles */
      document.querySelectorAll(".sidebar-section").forEach(section => {
        const header = section.querySelector(".sidebar-section-header");
        header.addEventListener("click", () => {
          section.classList.toggle("open");
        });
      });

      const contextSelect = document.getElementById("contextSelect");
      const contextCustomWrapper = document.getElementById("contextCustomWrapper");
      const contextCustom = document.getElementById("contextCustom");

      contextSelect.addEventListener("change", () => {
        if (contextSelect.value === "User-defined") {
          contextCustomWrapper.style.display = "block";
        } else {
          contextCustomWrapper.style.display = "none";
          contextCustom.value = "";
        }
      });

      /* Question data – from Feedback Scale */

      const questions = [
        // Volume and frequency
        { id: 1,  text: "I can go for weeks without getting any meaningful feedback on my work." },
        { id: 2,  text: "Most of the feedback I get is a quick thanks or looks fine without much detail." },
        { id: 3,  text: "I regularly get specific feedback that tells me what worked and why." },
        { id: 4,  text: "I often get a lot of comments from different people in a short space of time." },
        { id: 5,  text: "It can feel like feedback is arriving constantly, even while I am still working on something." },

        // Quality and usefulness
        { id: 6,  text: "Feedback usually helps me understand what to repeat or change next time." },
        { id: 7,  text: "I rarely hear about what is going well or what people value in my work." },
        { id: 8,  text: "I sometimes get mixed messages or conflicting feedback about the same piece of work." },
        { id: 9,  text: "Feedback focuses more on problems or urgency than on what would be helpful in future." },
        { id: 10, text: "When I ask for feedback, people are unsure what to say or postpone the conversation." },

        // Safety and tone
        { id: 11, text: "I feel comfortable asking for more detail or clarifying feedback if I do not understand it." },
        { id: 12, text: "I sometimes worry that being honest about feedback will be held against me later." },
        { id: 13, text: "Feedback sometimes feels rushed or dropped into the middle of other pressures." },
        { id: 14, text: "Important feedback is sometimes shared indirectly instead of being discussed with me." },
        { id: 15, text: "I usually have space to absorb feedback before more arrives." }
      ];

      const sections = [
        {
          id: "volume",
          title: "How often you get feedback",
          subtitle: "Frequency and consistency over the last few weeks.",
          questionIds: [1, 2, 3, 4, 5]
        },
        {
          id: "quality",
          title: "Quality and usefulness",
          subtitle: "Whether feedback helps you learn and make decisions.",
          questionIds: [6, 7, 8, 9, 10]
        },
        {
          id: "safety",
          title: "Safety and tone",
          subtitle: "How safe, respectful and workable feedback feels.",
          questionIds: [11, 12, 13, 14, 15]
        }
      ];

      // Zone membership by question (from Feedback Scale)
      const zoneQuestions = {
        silent:        [1, 7, 10],
        sparse:        [2, 14],
        resonant:      [3, 6, 11, 15],
        loud:          [4, 9, 13],
        overwhelming:  [5, 8, 12]
      };

      const zoneLabels = {
        silent: "Silent",
        sparse: "Sparse",
        resonant: "Resonant",
        loud: "Loud",
        overwhelming: "Overwhelming"
      };

      // No reverse scoring in this scale
      const reverseScored = new Set();

      const responseOptions = [
        { value: 0, label: "1" },
        { value: 1, label: "2" },
        { value: 2, label: "3" },
        { value: 3, label: "4" },
        { value: 4, label: "5" }
      ];

      /* Ring chart colours */

      const zoneColors = {
        silent:       { fill: "rgba(55,65,81,0.7)",   stroke: "#374151" },
        sparse:       { fill: "rgba(56,189,248,0.8)", stroke: "#0ea5e9" },
        resonant:     { fill: "rgba(34,197,94,0.8)",  stroke: "#16a34a" },
        loud:         { fill: "rgba(249,115,22,0.8)", stroke: "#ea580c" },
        overwhelming: { fill: "rgba(239,68,68,0.8)",  stroke: "#b91c1c" }
      };

      // Target patterns for each role level
      // Emphasis on high resonant, low silent and overwhelming
      const roleTargets = {
        L1: { silent: 10, sparse: 20, resonant: 50, loud: 15, overwhelming: 5 },
        L2: { silent: 8,  sparse: 18, resonant: 52, loud: 17, overwhelming: 5 },
        L3: { silent: 5,  sparse: 15, resonant: 55, loud: 20, overwhelming: 5 },
        L4: { silent: 5,  sparse: 12, resonant: 55, loud: 23, overwhelming: 5 },
        L5: { silent: 5,  sparse: 10, resonant: 55, loud: 25, overwhelming: 5 }
      };

      const roleLabels = {
        L1: "Operator",
        L2: "Senior operator",
        L3: "Supervisor",
        L4: "Manager",
        L5: "Director"
      };

      const roleLevelSelect = document.getElementById("roleLevel");
      const saveButton = document.getElementById("saveEntry");
      const exportButton = document.getElementById("exportCsv");
      const exportPdfButton = document.getElementById("exportPdf");
      const clearButton = document.getElementById("clearEntries");
      const loadSelect = document.getElementById("loadEntry");
      const calculationResults = document.getElementById("calculationResults");
      const overallResult = document.getElementById("overallResult");
      const entriesTableBody = document.querySelector("#entriesTable tbody");
      const calculateButton = document.getElementById("calculateFromQuestions");
      const donutLabel = document.getElementById("donutLabel");
      const boardWrapper = document.getElementById("boardWrapper");
      const boardInner = document.getElementById("boardInner");
      const assessmentCountSpan = document.getElementById("assessmentCount");

      let latestZonePercents = null;
      let latestZoneRaw = null;
      let latestTopZone = null;
      let latestTopScore = null;
      let latestResponses = null;
      let latestScaleScore = null;
      let latestFollowupText = "";

      /* Assessment counter */

      function loadAssessmentCount() {
        const raw = localStorage.getItem("feedbackScaleCount");
        const n = raw ? parseInt(raw, 10) || 0 : 0;
        assessmentCountSpan.textContent = n;
        return n;
      }

      function incrementAssessmentCount() {
        const n = loadAssessmentCount() + 1;
        localStorage.setItem("feedbackScaleCount", String(n));
        assessmentCountSpan.textContent = n;
      }

      loadAssessmentCount();

      /* Build questions UI */

      const questionSectionsContainer = document.getElementById("questionSections");
      const questionMap = new Map(questions.map(q => [q.id, q]));

      // helper: map questionId -> section wrapper
      const questionIdToSectionId = {};

      function buildQuestions() {
        sections.forEach(section => {
          const wrapper = document.createElement("div");
          wrapper.className = "question-section";
          wrapper.dataset.sectionId = section.id;

          const header = document.createElement("div");
          header.className = "question-section-header";

          const titleGroup = document.createElement("div");
          titleGroup.className = "question-section-title-group";

          const title = document.createElement("div");
          title.className = "question-section-title";
          title.textContent = section.title;

          const subtitle = document.createElement("div");
          subtitle.className = "question-section-subtitle";
          subtitle.textContent = section.subtitle;

          titleGroup.appendChild(title);
          titleGroup.appendChild(subtitle);

          const toggle = document.createElement("div");
          toggle.className = "question-section-toggle";
          toggle.textContent = "+";

          header.appendChild(titleGroup);
          header.appendChild(toggle);
          wrapper.appendChild(header);

          const body = document.createElement("div");
          body.className = "question-section-body";

          const table = document.createElement("table");
          table.className = "question-table";

          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");
          const thText = document.createElement("th");
          thText.className = "question-text";
          thText.textContent = "Statement";
          headRow.appendChild(thText);

          responseOptions.forEach(opt => {
            const th = document.createElement("th");
            th.textContent = opt.label;
            headRow.appendChild(th);
          });

          thead.appendChild(headRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");

          section.questionIds.forEach(id => {
            const q = questionMap.get(id);
            if (!q) return;

            const tr = document.createElement("tr");
            const tdText = document.createElement("td");
            tdText.className = "question-text";
            tdText.textContent = q.text;
            tr.appendChild(tdText);

            responseOptions.forEach(opt => {
              const td = document.createElement("td");
              td.className = "response-cell";

              const label = document.createElement("label");
              label.className = "response-radio";
              const input = document.createElement("input");
              input.type = "radio";
              input.name = `q${q.id}`;
              input.value = opt.value;

              const span = document.createElement("span");
              span.textContent = opt.label;

              label.appendChild(input);
              label.appendChild(span);
              td.appendChild(label);
              tr.appendChild(td);

              label.addEventListener("click", () => {
                document
                  .querySelectorAll(`label.response-radio input[name="q${q.id}"]`)
                  .forEach(r => r.parentElement.classList.remove("selected"));
                label.classList.add("selected");
              });
            });

            tbody.appendChild(tr);
            questionIdToSectionId[q.id] = section.id;
          });

          table.appendChild(tbody);
          body.appendChild(table);
          wrapper.appendChild(body);
          questionSectionsContainer.appendChild(wrapper);

          header.addEventListener("click", () => {
            const isOpen = wrapper.classList.contains("open");
            document
              .querySelectorAll(".question-section")
              .forEach(sec => sec.classList.remove("open"));
            if (!isOpen) {
              wrapper.classList.add("open");
            }
          });
        });

        const firstSection = document.querySelector(".question-section");
        if (firstSection) firstSection.classList.add("open");
      }

      buildQuestions();

      /* Ring chart */

      const ringCanvas = document.getElementById("zoneRing");
      const ringCtx = ringCanvas.getContext("2d");

      function drawRingChart(data) {
        const w = ringCanvas.width;
        const h = ringCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const maxRadius = Math.min(w, h) / 2 - 8;

        ringCtx.clearRect(0, 0, w, h);

        const order = ["silent", "sparse", "resonant", "loud", "overwhelming"];
        const values = data || { silent: 20, sparse: 20, resonant: 20, loud: 20, overwhelming: 20 };

        let innerR = 0;
        order.forEach(zone => {
          const pct = values[zone] ?? 0;
          const outerR = innerR + maxRadius * (pct / 100);
          if (outerR <= innerR) return;

          ringCtx.beginPath();
          ringCtx.arc(cx, cy, outerR, 0, 2 * Math.PI);
          ringCtx.arc(cx, cy, innerR, 2 * Math.PI, 0, true);
          ringCtx.closePath();
          ringCtx.fillStyle = zoneColors[zone].fill;
          ringCtx.fill();

          innerR = outerR;
        });

        ringCtx.beginPath();
        ringCtx.arc(cx, cy, maxRadius, 0, 2 * Math.PI);
        ringCtx.strokeStyle = "#000";
        ringCtx.lineWidth = 2;
        ringCtx.stroke();
      }

      function updateRingLegend(data, labelText) {
        const legend = document.getElementById("zoneRingLegend");
        const order = ["silent", "sparse", "resonant", "loud", "overwhelming"];
        const values = data || { silent: 20, sparse: 20, resonant: 20, loud: 20, overwhelming: 20 };
        const rows = order
          .map(zone => {
            const pct = values[zone] ?? 0;
            return `
              <div class="zone-legend-row">
                <span class="zone-legend-swatch" style="background:${zoneColors[zone].stroke};"></span>
                <span class="zone-legend-label">${zoneLabels[zone]}</span>
                <span class="zone-legend-value">${pct}%</span>
              </div>
            `;
          })
          .join("");
        legend.innerHTML = rows;
        donutLabel.textContent = labelText;
      }

      drawRingChart(null);
      updateRingLegend(null, "Equal starting pattern. Updates after calculation.");

      /* Scoring */

      function openSectionForQuestionId(qid) {
        const secId = questionIdToSectionId[qid];
        if (!secId) return;
        document
          .querySelectorAll(".question-section")
          .forEach(secEl => secEl.classList.remove("open"));
        const target = document.querySelector(`.question-section[data-section-id="${secId}"]`);
        if (target) {
          target.classList.add("open");
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function getResponses() {
        const responses = {};
        for (const q of questions) {
          const checked = document.querySelector(`input[name="q${q.id}"]:checked`);
          if (!checked) {
            openSectionForQuestionId(q.id);
            return null;
          }
          responses[q.id] = parseInt(checked.value, 10);
        }
        return responses;
      }

      function calculateZoneScores(responses) {
        const raw = {};
        const avg = {};
        let totalIntensity = 0;
        const zones = Object.keys(zoneQuestions);

        zones.forEach(zone => {
          const ids = zoneQuestions[zone];
          let sum = 0;
          ids.forEach(id => {
            const base = responses[id] ?? 0;
            const score = reverseScored.has(id) ? 4 - base : base;
            sum += score;
          });
          const mean = ids.length ? sum / ids.length : 0;
          raw[zone] = sum;
          avg[zone] = mean;
          totalIntensity += mean;
        });

        const percents = {};
        if (totalIntensity === 0) {
          zones.forEach(z => {
            percents[z] = 0;
          });
        } else {
          let running = 0;
          zones.forEach((zone, idx) => {
            if (idx === zones.length - 1) {
              percents[zone] = Math.max(0, 100 - running);
            } else {
              const p = Math.round((avg[zone] / totalIntensity) * 100);
              percents[zone] = p;
              running += p;
            }
          });
        }

        return { raw, percents };
      }

      function currentTarget(role) {
        return role ? roleTargets[role] : null;
      }

      function levelLabel(actual, ideal) {
        const diff = actual - ideal;
        if (Math.abs(diff) <= 5) return "close to target";
        if (diff > 5) return "higher than target";
        return "lower than target";
      }

      function zoneNarrative(zone, actual, ideal) {
        const level = levelLabel(actual, ideal);
        switch (zone) {
          case "silent":
            if (level === "higher than target")
              return "Silence is high; agree regular feedback touchpoints so you do not need to guess how things are going.";
            if (level === "lower than target")
              return "Silence is low; keep a light but predictable rhythm of feedback so useful conversations still happen.";
            return "Silence is close to the typical pattern; make sure quiet periods still include occasional check-ins.";
          case "sparse":
            if (level === "higher than target")
              return "Sparse feedback is common; ask for more specific examples so praise and concerns are easier to act on.";
            if (level === "lower than target")
              return "Quick, light feedback is less frequent; check whether this helps you stay focused or leaves too many gaps.";
            return "Sparse feedback is about where we expect; use it alongside more detailed conversations when needed.";
          case "resonant":
            if (level === "higher than target")
              return "Resonant feedback is strong; protect time for these conversations and keep them tied to real work.";
            if (level === "lower than target")
              return "Resonant feedback is low; agree ways to give more specific, timely and actionable feedback on real examples.";
            return "Resonant feedback is close to target; treat this as the pattern to build around.";
          case "loud":
            if (level === "higher than target")
              return "Loud feedback is frequent; slow some conversations down and focus on one or two clear messages at a time.";
            if (level === "lower than target")
              return "Loud feedback is low; make sure important signals still get through in a clear, visible way.";
            return "Loud feedback is close to target; useful for urgency, as long as it does not drown out resonant feedback.";
          case "overwhelming":
            if (level === "higher than target")
              return "Overwhelming feedback is high; reduce volume, agree boundaries and avoid stacking several messages at once.";
            if (level === "lower than target")
              return "Overwhelming feedback is low; keep that protection in place so difficult topics can be handled at a workable pace.";
            return "Overwhelming feedback is around the typical pattern; still useful to ask what tips things into feeling too much.";
          default:
            return "";
        }
      }

      function buildPatternCommentary(percents) {
        const flags = [];
        const praise = [];

        if (percents.silent >= 30) {
          flags.push(
            "Silent feedback at or above 30%: long gaps make it hard to know how you are doing; agree a regular rhythm of check-ins on real work."
          );
        }

        if (percents.overwhelming >= 20) {
          flags.push(
            "Overwhelming feedback at or above 20%: volume or emotional weight may be high; slow the flow and focus on fewer, clearer messages."
          );
        }

        if (percents.resonant >= 40 && percents.silent <= 15 && percents.overwhelming <= 10) {
          praise.push(
            "Resonant feedback is strong with limited silence and overwhelm; build on what is working and copy it into other relationships or projects."
          );
        }

        if (percents.sparse >= 30 && percents.resonant <= 25) {
          flags.push(
            "Sparse feedback is high and resonant feedback is lower; shift some comments from quick ok signals into more detailed, practical feedback."
          );
        }

        if (!flags.length && !praise.length) {
          praise.push(
            "No strong risk signals from this pattern. Use it to ask what is helping feedback land well and what a small next improvement would look like."
          );
        }

        return { flags, praise };
      }

      function buildConversationPromptsHtml(percents) {
        const { flags, praise } = buildPatternCommentary(percents);
        let html = '<div class="conversation-prompts">';
        if (praise.length) {
          html += "<strong>What seems to be working:</strong><ul>";
          praise.forEach(p => {
            html += `<li>${p}</li>`;
          });
          html += "</ul>";
        }
        if (flags.length) {
          html += "<strong>Things to adjust:</strong><ul>";
          flags.forEach(f => {
            html += `<li>${f}</li>`;
          });
          html += "</ul>";
        }
        html += "</div>";
        return html;
      }

      function getFollowupSuggestion(percents, role) {
        const target = currentTarget(role);
        const now = new Date();
        if (!target) {
          const weeks = 12;
          const future = new Date(now.getTime() + weeks * 7 * 24 * 60 * 60 * 1000);
          return {
            text: `Suggested time to redo this assessment: after around 3 months, around ${future.toLocaleDateString()}.`,
            dateLabel: future.toLocaleDateString()
          };
        }

        const zones = ["silent", "sparse", "resonant", "loud", "overwhelming"];
        let sumDiff = 0;
        zones.forEach(z => {
          sumDiff += Math.abs((percents[z] ?? 0) - target[z]);
        });
        const avgDiff = sumDiff / zones.length;

        let weeks;
        if (avgDiff >= 18) weeks = 6;
        else if (avgDiff >= 14) weeks = 8;
        else if (avgDiff >= 10) weeks = 12;
        else if (avgDiff >= 6) weeks = 24;
        else weeks = 52;

        const future = new Date(now.getTime() + weeks * 7 * 24 * 60 * 60 * 1000);
        const label =
          weeks === 52
            ? "about a year"
            : weeks === 24
            ? "about 6 months"
            : weeks === 12
            ? "about 3 months"
            : `${weeks} weeks`;

        return {
          text: `Suggested time to redo this assessment together: in ${label}, around ${future.toLocaleDateString()}.`,
          dateLabel: future.toLocaleDateString()
        };
      }

      function renderResults(percents, role, topZone, topScore) {
        const target = currentTarget(role);

        calculationResults.innerHTML = `
          <p><strong>Highest zone:</strong> ${zoneLabels[topZone]} (${topScore}%)</p>
          <p><strong>Pattern:</strong> Silent ${percents.silent}% · Sparse ${percents.sparse}% · Resonant ${percents.resonant}% · Loud ${percents.loud}% · Overwhelming ${percents.overwhelming}%</p>
          ${
            target
              ? `<table>
                   <thead>
                     <tr><th>Zone</th><th>Current</th><th>Target</th></tr>
                   </thead>
                   <tbody>
                     <tr><td>Silent</td><td>${percents.silent}%</td><td>${target.silent}%</td></tr>
                     <tr><td>Sparse</td><td>${percents.sparse}%</td><td>${target.sparse}%</td></tr>
                     <tr><td>Resonant</td><td>${percents.resonant}%</td><td>${target.resonant}%</td></tr>
                     <tr><td>Loud</td><td>${percents.loud}%</td><td>${target.loud}%</td></tr>
                     <tr><td>Overwhelming</td><td>${percents.overwhelming}%</td><td>${target.overwhelming}%</td></tr>
                   </tbody>
                 </table>`
              : ""
          }
          ${buildConversationPromptsHtml(percents)}
        `;

        renderOverallScale(percents, role, topZone);
        drawRingChart(percents);
        updateRingLegend(percents, "Current pattern");
      }

      function renderOverallScale(percents, role, topZone) {
        // Overall position: map zones to 1–5 feedback pattern score
        const scoreMap = {
          silent: 1,
          sparse: 2,
          resonant: 3,
          loud: 4,
          overwhelming: 5
        };
        const score = scoreMap[topZone] || 3;
        latestScaleScore = score;

        const desc = {
          1: {
            label: "Mostly Silent",
            text: "Feedback is infrequent or hard to find. It can be difficult to know what is working or where to focus.",
            manager: "Agree a light but regular rhythm of feedback on real pieces of work so progress is visible."
          },
          2: {
            label: "Mostly Sparse",
            text: "Feedback tends to be brief or general. You may know roughly how you are doing but not have many clear examples.",
            manager: "Shift some comments from quick ok signals into more specific, practical feedback."
          },
          3: {
            label: "Mostly Resonant",
            text: "Feedback is often specific and usable. You can see what to repeat and what to adjust next time.",
            manager: "Protect time for these conversations and keep linking them to real pieces of work."
          },
          4: {
            label: "Mostly Loud",
            text: "Feedback is active and urgent. Signals are clear but may arrive quickly or under pressure.",
            manager: "Slow some conversations down, focus on one or two messages at a time and connect them to future decisions."
          },
          5: {
            label: "Mostly Overwhelming",
            text: "Feedback feels heavy, frequent or emotionally loaded. It can be hard to process and act on it.",
            manager: "Reduce the volume and pace. Prioritise the most important messages and agree clearer timing and boundaries."
          }
        }[score];

        const target = currentTarget(role);

        let html = `
          <p><strong>Overall position:</strong> ${desc.label} (pattern score ${score}/5)</p>
          <p>${desc.text}</p>
          <p><strong>Manager focus:</strong> ${desc.manager}</p>
        `;

        if (target) {
          html += `<p><strong>Role pattern (${roleLabels[role]}):</strong> Silent ${target.silent}%, Sparse ${target.sparse}%, Resonant ${target.resonant}%, Loud ${target.loud}%, Overwhelming ${target.overwhelming}%.</p>`;
          html += `<table>
            <thead><tr><th>Zone</th><th>Comment</th></tr></thead>
            <tbody>
              ${["silent", "sparse", "resonant", "loud", "overwhelming"]
                .map(z => {
                  const actual = percents[z] ?? 0;
                  const ideal = target[z] ?? 0;
                  return `<tr><td>${zoneLabels[z]}</td><td>${zoneNarrative(
                    z,
                    actual,
                    ideal
                  )}</td></tr>`;
                })
                .join("")}
            </tbody>
          </table>`;
        }

        const follow = getFollowupSuggestion(percents, role);
        latestFollowupText = follow.text;
        html += `<p style="margin-top:0.4rem;"><strong>${follow.text}</strong></p>`;

        overallResult.innerHTML = html;
      }

      /* Local storage */

      function loadEntries() {
        try {
          return JSON.parse(localStorage.getItem("feedbackScaleEntries") || "[]");
        } catch {
          return [];
        }
      }

      function saveEntries(entries) {
        localStorage.setItem("feedbackScaleEntries", JSON.stringify(entries));
      }

      function renderEntriesTableAndDropdown() {
        const entries = loadEntries();
        entriesTableBody.innerHTML = "";
        loadSelect.innerHTML = '<option value="">Select saved entry</option>';

        entries.forEach((entry, index) => {
          const tr = document.createElement("tr");
          const zp = entry.zonePercents || {};
          tr.innerHTML = `
            <td>${entry.timestamp}</td>
            <td>${zp.silent ?? ""}%</td>
            <td>${zp.sparse ?? ""}%</td>
            <td>${zp.resonant ?? ""}%</td>
            <td>${zp.loud ?? ""}%</td>
            <td>${zp.overwhelming ?? ""}%</td>
          `;
          entriesTableBody.appendChild(tr);

          const opt = document.createElement("option");
          opt.value = index.toString();
          opt.textContent = `${entry.timestamp}`;
          loadSelect.appendChild(opt);
        });
      }

      renderEntriesTableAndDropdown();

      function storeEntry(autoSave) {
        if (!latestZonePercents || !latestTopZone) return;

        const name = document.getElementById("personName").value.trim();
        const roleLevel = roleLevelSelect.value || "";
        let contextValue = "";
        if (contextSelect.value === "User-defined") {
          contextValue = contextCustom.value.trim();
        } else {
          contextValue = contextSelect.value;
        }

        const scoreMap = { silent: 1, sparse: 2, resonant: 3, loud: 4, overwhelming: 5 };
        const score = scoreMap[latestTopZone] || latestScaleScore || 3;
        const entries = loadEntries();
        const timestamp = new Date().toLocaleString();
        entries.push({
          timestamp,
          name,
          roleLevel,
          context: contextValue,
          score,
          zonePercents: latestZonePercents,
          zoneRaw: latestZoneRaw,
          responses: latestResponses
        });
        saveEntries(entries);
        renderEntriesTableAndDropdown();
      }

      function toCsvRow(cells) {
        return cells
          .map(cell => {
            const val = cell == null ? "" : String(cell);
            if (/[",\n]/.test(val)) {
              return '"' + val.replace(/"/g, '""') + '"';
            }
            return val;
          })
          .join(",");
      }

      function handleExportCsv() {
        const entries = loadEntries();
        if (!entries.length) {
          alert("No entries to export.");
          return;
        }
        const headers = [
          "Timestamp",
          "Name",
          "RoleLevel",
          "Context",
          "Score",
          "ZoneLabel",
          "Silent%",
          "Sparse%",
          "Resonant%",
          "Loud%",
          "Overwhelming%"
        ];
        questions.forEach(q => headers.push(`Q${q.id}`));
        const rows = [toCsvRow(headers)];

        entries.forEach(entry => {
          const zp = entry.zonePercents || {};
          const responses = entry.responses || {};
          const top = Object.entries(zp).sort((a, b) => b[1] - a[1])[0];
          const topLabel = top ? zoneLabels[top[0]] : "";
          const row = [
            entry.timestamp,
            entry.name || "",
            entry.roleLevel || "",
            entry.context || "",
            entry.score,
            topLabel,
            zp.silent ?? "",
            zp.sparse ?? "",
            zp.resonant ?? "",
            zp.loud ?? "",
            zp.overwhelming ?? ""
          ];
          questions.forEach(q => row.push(responses[q.id] ?? ""));
          rows.push(toCsvRow(row));
        });

        const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "Feedback_Scale_Entries.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function handleClearEntries() {
        if (!confirm("Clear all saved entries in this browser?")) return;
        localStorage.removeItem("feedbackScaleEntries");
        renderEntriesTableAndDropdown();
      }

      function handleLoadEntry() {
        const idx = parseInt(loadSelect.value, 10);
        if (Number.isNaN(idx)) return;

        const entries = loadEntries();
        const entry = entries[idx];
        if (!entry) return;

        document.getElementById("personName").value = entry.name || "";
        roleLevelSelect.value = entry.roleLevel || "";

        if (entry.context) {
          const preset = Array.from(contextSelect.options).some(
            opt => opt.value === entry.context
          );
          if (preset) {
            contextSelect.value = entry.context;
            contextCustomWrapper.style.display = "none";
            contextCustom.value = "";
          } else {
            contextSelect.value = "User-defined";
            contextCustomWrapper.style.display = "block";
            contextCustom.value = entry.context;
          }
        } else {
          contextSelect.value = "";
          contextCustomWrapper.style.display = "none";
          contextCustom.value = "";
        }

        questions.forEach(q => {
          document
            .querySelectorAll(`label.response-radio input[name="q${q.id}"]`)
            .forEach(r => {
              r.checked = false;
              r.parentElement.classList.remove("selected");
            });
        });

        if (entry.responses) {
          Object.entries(entry.responses).forEach(([qid, val]) => {
            const radio = document.querySelector(
              `label.response-radio input[name="q${qid}"][value="${val}"]`
            );
            if (radio) {
              radio.checked = true;
              radio.parentElement.classList.add("selected");
            }
          });
        }

        latestResponses = entry.responses || null;
        let percents = entry.zonePercents;
        let raw = entry.zoneRaw;

        if (!percents && entry.responses) {
          const calc = calculateZoneScores(entry.responses);
          percents = calc.percents;
          raw = calc.raw;
        }
        if (!percents) {
          alert("This saved entry does not contain enough data to reconstruct scores.");
          return;
        }

        latestZonePercents = percents;
        latestZoneRaw = raw;
        const entriesArr = Object.entries(percents).sort((a, b) => b[1] - a[1]);
        const [topZone, topScore] = entriesArr[0] || ["resonant", 0];
        latestTopZone = topZone;
        latestTopScore = topScore;
        const role = roleLevelSelect.value || null;
        renderResults(percents, role, topZone, topScore);
      }

      saveButton.addEventListener("click", () => storeEntry(false));
      exportButton.addEventListener("click", handleExportCsv);
      clearButton.addEventListener("click", handleClearEntries);
      loadSelect.addEventListener("change", handleLoadEntry);

      /* Calculate – default role to L1 if not set */

      function handleCalculate() {
        if (!roleLevelSelect.value) {
          roleLevelSelect.value = "L1";   // assume Operator
        }

        const responses = getResponses();
        if (!responses) {
          alert("Please answer all questions before calculating. The section with the first missing answer has been opened.");
          return;
        }

        calculateButton.classList.add("calculating");
        boardWrapper.classList.add("calculated");

        const { raw, percents } = calculateZoneScores(responses);
        const entriesArr = Object.entries(percents).sort((a, b) => b[1] - a[1]);
        const [topZone, topScore] = entriesArr[0] || ["resonant", 0];

        latestZonePercents = percents;
        latestZoneRaw = raw;
        latestTopZone = topZone;
        latestTopScore = topScore;
        latestResponses = responses;

        const role = roleLevelSelect.value || null;
        renderResults(percents, role, topZone, topScore);

        storeEntry(true);
        incrementAssessmentCount();

        setTimeout(() => {
          calculateButton.classList.remove("calculating");
          boardWrapper.classList.remove("calculated");
        }, 1200);
      }

      calculateButton.addEventListener("click", handleCalculate);

      roleLevelSelect.addEventListener("change", () => {
        if (!latestZonePercents) return;
        const role = roleLevelSelect.value || null;
        const entriesArr = Object.entries(latestZonePercents).sort((a, b) => b[1] - a[1]);
        const [topZone, topScore] = entriesArr[0] || ["resonant", 0];
        renderResults(latestZonePercents, role, topZone, topScore);
      });

      /* Fullscreen */

      document.getElementById("fullscreenToggle").addEventListener("click", () => {
        if (!document.fullscreenElement) {
          boardWrapper.requestFullscreen?.();
        } else {
          document.exitFullscreen?.();
        }
      });

      /* PDF export */

      async function handleExportPdf() {
        const { jsPDF } = window.jspdf;

        const sectionEls = Array.from(document.querySelectorAll(".question-section"));
        const openState = sectionEls.map(el => el.classList.contains("open"));
        sectionEls.forEach(el => el.classList.add("open"));

        boardInner.classList.add("export-mode");

        const exportHeader = document.createElement("div");
        exportHeader.className = "export-header";
        const name = document.getElementById("personName").value.trim() || "Not specified";
        const role =
          roleLabels[roleLevelSelect.value] ||
          (roleLevelSelect.value || "Not specified");
        let contextValue = "";
        if (contextSelect.value === "User-defined") {
          contextValue = contextCustom.value.trim();
        } else {
          contextValue = contextSelect.value || "";
        }
        const contextLabel = contextValue || "Not specified";
        const now = new Date();
        const dateString = now.toLocaleString();
        const dateTag = now.toISOString().slice(0, 10);

        const isTemplate = !latestZonePercents;
        const suggestionText =
          latestFollowupText ||
          (isTemplate
            ? "Template saved before any answers were calculated."
            : "");

        exportHeader.innerHTML = `
          <div class="export-header-title">Feedback scale assessment</div>
          <div class="export-header-meta">
            Name: ${name} · Role: ${role} · Context: ${contextLabel} · Date: ${dateString}
          </div>
          <div class="export-highlight">
            This tool maps how feedback has felt across Silent, Sparse, Resonant, Loud and Overwhelming. Resonant feedback is usually the most useful: specific, timely and focused on what to repeat or change. Silent and Overwhelming feedback are signals that the system needs adjusting, not a judgement on any individual.
          </div>
          <div class="export-suggestion">
            ${suggestionText}
          </div>
        `;
        boardInner.insertBefore(exportHeader, boardInner.firstChild);

        const exportFooter = document.createElement("div");
        exportFooter.className = "export-footer";
        const url = "https://imthebus.co.uk/web-tools/feedback-scale.html";
        exportFooter.textContent = `Generated from IMTHEBUS Feedback scale tool (${url}) on ${dateString}`;
        boardInner.appendChild(exportFooter);

        const headerEl = document.querySelector(".b2p-board-header");
        let originalBoardHeaderDisplay = "";
        if (headerEl) {
          originalBoardHeaderDisplay = headerEl.style.display;
          headerEl.style.display = "none";
        }

        const canvas = await html2canvas(boardWrapper, { scale: 2 });
        const img = canvas.toDataURL("image/jpeg", 0.9);

        const pdf = new jsPDF("p", "mm", "a4");
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgProps = pdf.getImageProperties(img);
        const imgWidth = pageWidth;
        const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

        let remainingHeight = imgHeight;
        let position = 0;

        pdf.addImage(img, "JPEG", 0, 0, imgWidth, Math.min(pageHeight, remainingHeight));
        remainingHeight -= pageHeight;
        position = -pageHeight;

        while (remainingHeight > 0) {
          pdf.addPage();
          position += pageHeight;
          pdf.addImage(
            img,
            "JPEG",
            0,
            position,
            imgWidth,
            Math.min(pageHeight, remainingHeight)
          );
          remainingHeight -= pageHeight;
        }

        const safeName =
          name && name !== "Not specified"
            ? name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "")
            : "";
        const filename =
          "Feedback_Scale" +
          (safeName ? "_" + safeName : "") +
          "_" +
          dateTag +
          ".pdf";

        pdf.save(filename);

        boardInner.removeChild(exportHeader);
        boardInner.removeChild(exportFooter);
        sectionEls.forEach((el, i) => {
          if (openState[i]) el.classList.add("open");
          else el.classList.remove("open");
        });
        boardInner.classList.remove("export-mode");

        if (headerEl) headerEl.style.display = originalBoardHeaderDisplay || "";
      }

      exportPdfButton.addEventListener("click", handleExportPdf);
    });
  </script>
</body>
</html>
